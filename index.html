<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Safe Gap: Final Mechanics (Full Hitbox)</title>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&display=swap');

        body {
            background-color: #111;
            margin: 0; height: 100vh; overflow: hidden;
            display: block; color: white; font-family: 'Segoe UI', sans-serif;
            user-select: none;
            transition: filter 0.3s;
        }
        body.reversed { filter: hue-rotate(180deg) contrast(1.2); }
        
        /* SCREEN SHAKE */
        .shake-screen { animation: shake-anim 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        .shake-hard { animation: shake-anim 0.8s cubic-bezier(.36,.07,.19,.97) both; } 
        @keyframes shake-anim {
            10%, 90% { transform: translate3d(-5px, 0, 0); }
            20%, 80% { transform: translate3d(5px, -5px, 0); }
            30%, 50%, 70% { transform: translate3d(-10px, 5px, 0); }
            40%, 60% { transform: translate3d(10px, -5px, 0); }
        }

        /* UI & BOSS HP */

        /* --- 2. CONTAINER CHÍNH --- */
        #boss-hud {
            position: fixed;
            top: 30px; 
            left: 50%;
            transform: translateX(-50%);
            width: 800px; /* Kích thước tổng của cả cái khung ảnh */
            display: none; 
            flex-direction: column;
            align-items: center;
            z-index: 10001;
            animation: hud-appear 1.2s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }

        @keyframes hud-appear {
            from { top: -150px; opacity: 0; filter: blur(5px); }
            to { top: 30px; opacity: 1; filter: blur(0); }
        }

        #boss-name {
            font-family: 'Creepster', cursive;
            color: #ccff00; /* Màu chữ xanh neon */
            font-size: 48px;
            letter-spacing: 4px;
            margin-bottom: -10px; /* Đè chữ xuống khung một xíu */
            z-index: 20;
            text-shadow: 
                0 0 10px #00ff00, 
                3px 3px 0 #002200,
                -1px -1px 0 #000; /* Viền đen giúp chữ nổi bật hơn */
        }

        .hud-wrapper {
            position: relative;
            width: 100%;
            height: 150px; /* Tăng chiều cao vùng chứa để không bị cắt ảnh */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* ẢNH KHUNG (LAYER TRÊN) */
        #boss-frame-img {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: contain;
            z-index: 10; 
            pointer-events: none;
            /* Thêm chút bóng đổ cho khung có chiều sâu */
            filter: drop-shadow(0 10px 10px rgba(0,0,0,0.8));
        }

        /* THANH MÁU (LAYER DƯỚI) */
        #hp-track {
            position: absolute;
            
            /* --- TINH CHỈNH VỊ TRÍ --- */
            top: 58px;       
            left: 138px;     /* Kéo lùi từ 170px về 138px để lấp lỗ hổng bên trái */
            width: 612px;    /* Tăng chiều dài để bù vào phần vừa kéo */
            height: 32px;    
            /* -------------------------- */
            
            background: #000; 
            
            /* Bo góc bên trái và phải khác nhau để khớp khung */
            border-radius: 10px 6px 6px 10px; 
            
            z-index: 5;          
            overflow: hidden;    
            box-shadow: inset 0 0 10px #000;
        }

        /* CHẤT LỎNG ĐỘC (Gân guốc + Đậm hơn) */
        #hp-fill {
            width: 100%; 
            height: 100%;
            
            /* Màu nền xanh đậm (Dark Toxic) */
            background-color: #004d00; 

            /* Họa tiết gân và bóng */
            background-image: 
                linear-gradient(to bottom, rgba(255,255,255,0.2) 0%, transparent 40%, rgba(0,0,0,0.5) 100%),
                repeating-linear-gradient(
                    45deg, 
                    transparent, 
                    transparent 10px, 
                    rgba(0, 0, 0, 0.5) 12px, 
                    rgba(0, 0, 0, 0.5) 16px
                ),
                radial-gradient(circle at 30% 50%, #00cc00 0%, #002200 90%);

            background-size: 100% 100%, 20px 20px, 100% 100%;
            box-shadow: inset 0 0 15px #00ff00;
            transition: width 0.3s ease-out;
            position: relative;
        }

        /* HIỆU ỨNG CHẤT LỎNG CHẢY */
        #hp-fill::after {
            content: '';
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            
            /* Tạo đốm sáng trôi nổi bên trong */
            background-image: radial-gradient(rgba(255,255,255,0.3) 15%, transparent 16%);
            background-size: 30px 30px; /* Kích thước bọt khí */
            
            animation: flow-toxic 2s linear infinite;
            opacity: 0.6;
        }

        @keyframes flow-toxic {
            0% { background-position: 0 0; }
            100% { background-position: 50px 0; } /* Trôi sang phải */
        }
        /* ORB */
        #energy-orb {
            position: fixed; width: 60px; height: 60px; z-index: 550;
            background: radial-gradient(circle, #ccff00 20%, transparent 70%);
            border: 2px solid #aaff00; border-radius: 50%;
            box-shadow: 0 0 20px #aaff00, inset 0 0 20px white;
            display: none; pointer-events: none;
            animation: orb-spin 1s infinite linear;
        }
        @keyframes orb-spin { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        /* GAME OVER */
        #game-over { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(80, 0, 0, 0.95); z-index: 99999; display: none; flex-direction: column; align-items: center; justify-content: center; }
        #go-text { font-size: 100px; color: red; font-family: 'Impact'; letter-spacing: 5px; text-shadow: 5px 5px 0 #000; border: 8px solid red; padding: 20px 80px; background: black; margin-bottom: 20px; }
        #restart-btn { font-size: 30px; color: white; cursor: pointer; text-transform: uppercase; font-weight: bold; animation: text-flicker 1s infinite alternate; }
        @keyframes text-flicker { from { opacity: 1; } to { opacity: 0.6; } }

        .warning-zone { position: fixed; left: 0; width: 100%; height: 200px; background: linear-gradient(90deg, rgba(255,0,0,0.6) 0%, transparent 90%); border-left: 15px solid red; z-index: 50; display: none; pointer-events: none; align-items: center; padding-left: 30px; }
        .warn-text { color: #ff3333; font-family: 'Impact', sans-serif; font-size: 80px; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 10px #000; background: rgba(0,0,0,0.8); padding: 5px 20px; border: 2px solid red; animation: panic 0.1s infinite alternate; }
        @keyframes panic { from{opacity:1; transform:scale(1);} to{opacity:0.8; transform:scale(1.02);} }
        
        #tunnel-indicator { position: fixed; left: 30px; top: 50%; transform: translateY(-50%); display: none; flex-direction: column; align-items: center; z-index: 9000; }
        .arrow { font-size: 120px; color: #ff3333; line-height: 0.6; display: none; animation: pulse 0.3s infinite alternate; -webkit-text-stroke: 3px darkred; }
        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.3); } }

        /* MEGA BOSS */
        #snake-1 { z-index: 10 !important; }
        #mega-boss-container { 
            position: fixed; right: -1000px; top: 50%; transform: translateY(-50%); 
            width: 800px; height: 800px; 
            transition: right 2s ease-out; 
            pointer-events: none; display: flex; justify-content: center; align-items: center;
            /* Boss chính: Tăng từ 10 lên 12 để chắc chắn nằm trên Snake-1 nhưng dưới Snake-2 */
            z-index: 12 !important; 
        }

        /* Snake-2 (Rắn dưới): Giữ nguyên 15 (đã cao hơn 10 và 12) */
        #snake-2 { 
            transform-origin: center; 
            display: flex; 
            align-items: center; 
            z-index: 15 !important;
            transform: scaleX(-1); 
        }

        /* 2. ĐẦU RẮN: Nằm trên cùng, kích thước to 350px */
        #head-2 { 
            position: relative;
            z-index: 9999 !important; /* Luôn nằm trên thân */
            
            /* Ép kích thước to */
            height: 350px !important;
            width: auto !important;
            
            /* Chỉnh khớp nối để đầu dính vào thân */
            margin-right: -240px !important; 
            
            image-rendering: pixelated;
            filter: drop-shadow(0 0 10px rgba(0,0,0,0.5));
        }

        /* 3. THÂN RẮN DƯỚI: Kích thước to 350px */
        #snake-2 .snake-segment {
            height: 350px !important; /* Ép to bằng đầu */
            width: auto !important;
            z-index: 1; /* Thấp hơn đầu */
            margin-right: -180px; /* Độ chồng khít các đốt */
        }

        #mega-boss-img { width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; filter: drop-shadow(0 0 20px rgba(128, 0, 128, 0.5)); transition: transform 0.2s, filter 0.2s; }
        
        .boss-hit-anim { animation: boss-pain 0.4s ease-in-out; }
        @keyframes boss-pain { 0% { filter: drop-shadow(0 0 20px red) brightness(2) hue-rotate(90deg); transform: scale(1.05); } 100% { filter: drop-shadow(0 0 20px purple); transform: scale(1); } }
        
        #sonic-wave { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; border-radius: 50%; border: 10px solid gold; transform: translate(-50%, -50%); opacity: 0; display: none; z-index: 21; }
        .animate-wave { animation: shockwave 1s ease-out forwards; }
        @keyframes shockwave { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; border-width: 20px; } 100% { transform: translate(-2000px, -50%) scale(25); opacity: 0; border-width: 0px; } }

        #poison-area-layer { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; 
            /* Hạ Z-Index tổng xuống 1 (Thấp hơn Boss là 10+) */
            z-index: 1; 
        }

        .poison-puddle {
            position: absolute; 
            width: 180px; height: 180px;
            background-image: url('Image/posionarea.png'); 
            background-size: contain; 
            background-repeat: no-repeat; 
            background-position: center;
            
            /* Mặc định độ mờ là 0.95 */
            opacity: 0.95; 
            
            filter: drop-shadow(0 0 5px #800080);
            z-index: 1; 
            display: none; 
            will-change: transform, opacity;

            transform: scale(0);
            
            /* [UPDATED] Thêm opacity vào transition */
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.5s ease;
            
            transform-origin: center;
        }

        /* [NEW] Class hiệu ứng tan biến */
        .puddle-vanish {
            transform: scale(1.5) !important; /* Phóng to ra */
            opacity: 0 !important;            /* Mờ dần đi */
            pointer-events: none;             /* Không thể va chạm khi đang tan */
        }
        /* Bãi độc từng cục */
        .safe-area-indicator {
            position: absolute;
            width: 240px; height: 240px; /* Radius 120 * 2 = 240px */
            border-radius: 50%;
            border: 5px dashed #00ff00;
            background: rgba(0, 255, 0, 0.15);
            box-shadow: 0 0 30px #00ff00, inset 0 0 20px #00ff00;
            transform: translate(-50%, -50%);
            z-index: 639;
            pointer-events: none;
            /* Hiệu ứng nhấp nháy báo hiệu hãy chui vào đây */
            animation: safe-pulse 0.15s infinite alternate; 
        }
        @keyframes safe-pulse {
            from { opacity: 0.6; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        }        

        .area-warning-box {
            position: absolute; width: 100px; height: 100%;
            background: repeating-linear-gradient(
                45deg,
                rgba(128, 0, 128, 0.1),
                rgba(128, 0, 128, 0.1) 10px,
                rgba(128, 0, 128, 0.2) 10px,
                rgba(128, 0, 128, 0.2) 20px
            );
            border-left: 2px dashed purple; border-right: 2px dashed purple;
            box-sizing: border-box;
            z-index: 640;
            animation: warn-blink 0.2s infinite;
        }
        @keyframes warn-blink { from { opacity: 0.3; } to { opacity: 0.8; } }

        /* PLAYER VFX */
        #player-fx-container { position: fixed; left: 20%; top: 50%; width: 0; height: 0; z-index: 490; pointer-events: none; transform: translateX(35px); }
        .player-aura { position: absolute; top: 0; left: 0; transform: translate(-50%, -50%); width: 80px; height: 80px; border-radius: 50%; border: 5px solid cyan; opacity: 0; display: none; }
        .anim-pulse { display: block; animation: pulse-aura 0.6s infinite; }
        @keyframes pulse-aura { 0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.8; border-width: 5px; } 100% { transform: translate(-50%, -50%) scale(1.8); opacity: 0; border-width: 0px; } }
        .player-burst { position: absolute; top: 0; left: 0; transform: translate(-50%, -50%); width: 50px; height: 50px; border-radius: 50%; border: 10px solid white; box-shadow: 0 0 20px cyan; opacity: 0; display: none; }
        .anim-burst { display: block; animation: burst-out 0.5s ease-out forwards; }
        @keyframes burst-out { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; border-width: 15px; } 100% { transform: translate(-50%, -50%) scale(6); opacity: 0; border-width: 0px; } }

        /* Buffed VFX */
        .buffed-aura { 
            width: 800px !important; height: 800px !important;
            border: 2px solid rgba(255, 215, 0, 0.3) !important;
            box-shadow: 0 0 100px 30px rgba(255, 215, 0, 0.2), inset 0 0 100px rgba(255, 215, 0, 0.2);
            opacity: 0.5 !important;
            display: none;
        }
        .buffed-burst { border-color: #ffffaa !important; box-shadow: 0 0 50px #ff0000; animation: burst-buff-out 0.8s ease-out forwards !important; }
        @keyframes burst-buff-out { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; border-width: 30px; background: rgba(255, 215, 0, 0.5); } 100% { transform: translate(-50%, -50%) scale(15); opacity: 0; border-width: 0px; background: transparent; } }

        /* ENTITIES */
        .boss-head { display: block; width: 450px; position: relative; z-index: 1000; image-rendering: pixelated; }
        #head-2 { 
            position: relative;
            z-index: 9999 !important; /* Đảm bảo đầu luôn nằm trên thân */
        }
        .snake-segment { display: block; height: 350px; z-index: 1; pointer-events: none; image-rendering: pixelated; }
        .snake-container { position: fixed; top: 0; left: 0; display: flex; align-items: center; width: max-content; will-change: transform; display: none; transition: opacity 0.5s; }
        #snake-2 { transform-origin: top left; }

        #player-dragon { position: fixed; width: 80px; height: auto; z-index: 500; image-rendering: pixelated; left: 20%; top: 50%; display: block; filter: drop-shadow(0 0 5px white); transform: translateY(-50%); } 
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 999; }
        #start-msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: yellow; font-family: 'Arial Black', sans-serif; font-size: 40px; text-shadow: 0 0 20px red; text-align: center; pointer-events: none; }
        #immortal-hit { position: fixed; top:0; left:0; width:100%; height:100%; border: 10px solid lime; box-sizing: border-box; z-index: 99998; display: none; pointer-events: none; box-shadow: inset 0 0 50px lime; }
        
        #status-corner { position: fixed; top: 10px; right: 10px; z-index: 10000; font-family: monospace; font-size: 14px; text-align: right; color: #0f0; background: rgba(0,0,0,0.7); padding: 10px; border: 1px solid #0f0; }
        #hitbox-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; display: none; }
        
        /* Debug Hitbox */
        .debug-box { position: absolute; border: 3px solid rgba(0, 255, 0, 0.7); background: rgba(0, 255, 0, 0.2); color: lime; font-weight: 900; font-family: sans-serif; font-size: 12px; display: flex; justify-content: center; align-items: center; box-sizing: border-box; }
        .debug-danger { border: 4px solid red; background: rgba(255, 0, 0, 0.3); color: white; box-shadow: 0 0 10px rgba(255,0,0,0.3); }
        .debug-orb { border: 2px solid yellow; background: transparent; border-radius: 50%; }
        
        #baby-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 600; }
        .baby-warn-line { position: absolute; left: 0; width: 100%; height: 2px; background-color: #ff0000; box-shadow: 0 0 10px #ff0000; opacity: 0; animation: warn-flash 0.5s linear forwards; }
        @keyframes warn-flash { 0% { opacity: 0; width: 0%; left: 100%; } 50% { opacity: 1; width: 100%; left: 0; } 100% { opacity: 0; } }
        .baby-snake { 
            position: absolute; 
            width: 120px; 
            height: 30px; 
            object-fit: contain; 
            image-rendering: pixelated; 
            z-index: 601; 
        }

        #bullet-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 650; }
        
        /* ĐÃ SỬA CSS ĐẠN ĐỘC: Bỏ hiệu ứng xoay (animation: bullet-spin) */
        .poison-bullet {
            position: absolute; 
            width: 120px; height: 120px;
            background-image: url('Image/posionbullet.png'); 
            background-size: contain; 
            background-repeat: no-repeat; 
            background-position: center;
        }

        .b-part {
            position: absolute;
            width: 12px; height: 12px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 99999;
            animation: part-anim 0.8s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
        }

        @keyframes part-anim {
            0% { 
                transform: translate(-50%, -50%) scale(1); 
                opacity: 1; 
            }
            100% { 
                transform: translate(var(--tx), var(--ty)) scale(0); 
                opacity: 0; 
            }
        }
        .anim-charge {
            display: block;
            border-color: #ff3300 !important; /* Màu cam đỏ cảnh báo */
            box-shadow: 0 0 30px #ff3300;
            animation: charge-in 2s cubic-bezier(0.25, 1, 0.5, 1) forwards;
        }

        @keyframes charge-in {
            0% { 
                transform: translate(-50%, -50%) scale(5); 
                opacity: 0;
                border-width: 2px;
            }
            100% { 
                /* Co về người chơi */
                transform: translate(-50%, -50%) scale(0.5); 
                opacity: 1;
                border-width: 10px;
            }
        }

        /* Animation Boss Gồng (Rung + Đỏ) */
        .boss-charge-fx {
            animation: boss-angry-shake 0.1s infinite;
            
            /* Xóa màu đỏ, thay bằng hiệu ứng Phát Quang (Glow) */
            /* Brightness: Tăng độ sáng */
            /* Contrast: Tăng tương phản để nổi bật các chi tiết sáng */
            /* Saturate: Làm màu rực rỡ hơn */
            /* Drop-shadow: Tạo hào quang tỏa ra xung quanh */
            filter: brightness(1.4) contrast(1.3) saturate(1.5) drop-shadow(0 0 15px #00ff00) !important;
        }

        @keyframes boss-angry-shake {
            0% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-3px) scale(1.01); } /* Rung nhẹ hơn xíu để đỡ mỏi mắt */
            100% { transform: translateY(3px) scale(1); }
        }
    </style>
</head>
<body>
    <div id="game-over"><div id="go-text">CHẾT RỒI!</div><div id="restart-btn">BẤM F5 CHƠI LẠI</div></div>
    <div id="warn-1" class="warning-zone"><div class="warn-text">⚠ CAUTION ⚠</div></div>
    <div id="warn-2" class="warning-zone"><div class="warn-text">⚠ CAUTION ⚠</div></div>
    <div id="tunnel-indicator"><div class="arrow arrow-up">▲</div><div class="arrow arrow-down">▼</div></div>
    <div id="immortal-hit"></div>
    <div id="energy-orb"></div>
    <div id="boss-hud">
        <!-- ĐÃ ĐỔI TÊN -->
        <div id="boss-name">THE PHANTOM LEVIATHAN</div>

        <div class="hud-wrapper">
            <!-- LAYER 1 (DƯỚI): Thanh máu -->
            <div id="hp-track">
                <div id="hp-fill"></div>
            </div>

            <!-- LAYER 2 (TRÊN): Khung ảnh PNG -->
            <!-- Đảm bảo đường dẫn ảnh đúng -->
            <img src="Image/BossFrame.png" id="boss-frame-img" alt="Boss Frame">
        </div>
    </div>
    <div id="status-corner">
        GOD MODE: <span id="lbl-god" style="color: lime; font-weight: bold;">ON</span><br>
        [G]: God | [H]: Hitbox<br>
        <div id="fps-counter">FPS: 0</div>
    </div>
    <div id="player-fx-container">
        <div id="p-warn-ring" class="player-aura"></div>
        <div id="p-dispel-ring" class="player-burst"></div>
    </div>
    <div id="mega-boss-container">
        <img src="Image/head.gif" id="mega-boss-img">
        <div id="sonic-wave"></div>
    </div>
    
    <div id="poison-area-layer"></div>

    <div id="baby-container"></div>
    <div id="bullet-container"></div>

    <div id="hitbox-layer">
        <div id="hb-player" class="debug-box"></div>
        <div id="hb-orb" class="debug-box debug-orb"></div>
        <div id="hb-s1-head" class="debug-box debug-danger"></div>
        <div id="hb-s1-body" class="debug-box debug-danger"></div>
        <div id="hb-s2-head" class="debug-box debug-danger"></div>
        <div id="hb-s2-body" class="debug-box debug-danger"></div>
        <div id="hb-dynamic-layer"></div> 
    </div>
    
    <div id="ui-layer"><div id="start-msg">BẤM [SPACE] ĐỂ CHIẾN</div></div>
    
    <div id="snake-1" class="snake-container">
        <img src="Image/head.gif" class="boss-head" id="head-1" style="margin-right:-260px">
        <div class="body-parts" style="display: flex;"></div>
    </div>
    <div id="snake-2" class="snake-container">
        <img src="Image/head.gif" class="boss-head" id="head-2" style="margin-right:-260px">
        <div class="body-parts" style="display: flex;"></div>
    </div>
    <img src="Image/dragon.png" id="player-dragon">

    <script>
        // CONFIG
        let GOD_MODE = true;
        const BOSS_CFG = {
            waveDelay: 1930,         
            revMin: 4000, revMax: 8000,
            coolMin: 4000, coolMax: 10000,          
            normal: { width: 800, right: -300, topInfo: 0 },
            skill:  { width: 950, right: -500, topInfo: 0 }
        };
        const CFG = {
            // Sửa safePadding từ 205 lên 260
            s1_BaseY: -140, s2_BaseY: 380, safePadding: 260,    
            
            dashSpeed: 28, minSpeed: 11, maxSpeed: 35,
            hb_S1_Width: 200, hb_S2_Width: 600, 
            s1_SafeY_Intro: -280, randRange: 180, posLerp: 0.05, 
            t_runWait: 300, t_stable: 200, t_warn: 80, tunnelSpeed: 0.03, 
            bodySrc: 'Image/body.png', segmentOverlap: -180,
            gravity: 0.45, jumpForce: -10.5, termVelocity: 16
        };

        function spawnBody(id) {
            const container = document.querySelector(`#${id} .body-parts`);
            let html = '';
            for(let i=0; i<800; i++) html += `<img src="${CFG.bodySrc}" class="snake-segment" style="margin-right:${CFG.segmentOverlap}px; z-index:${800-i}">`;
            container.innerHTML = html;
        }
        spawnBody('snake-1'); spawnBody('snake-2');

        let lastTime=0, gameTime=0; 
        let s1 = { active: false, destroyed: false, x: 2000, y: CFG.s1_BaseY, currentSpd: 0, destSpd: 20, destY: CFG.s1_BaseY, timers: [0,0] };
        let s2 = { active: false, destroyed: false, x: 0, y: CFG.s2_BaseY, currentSpd: 0, destSpd: 20, destY: CFG.s2_BaseY, timers: [0,0] };
        
        let gameState='IDLE', phase=0, phaseTimer=0, showHitbox=false;
        let tunnel = { y: window.innerHeight/2, targetY: window.innerHeight/2, timer: 0, state: 'IDLE' };
        let dragon = { y: window.innerHeight/2, vy: 0 };
        
        let megaBoss = { spawned: false, state: 'IDLE', stateTimer: 0, hp: 100, canUseSkill: true };
        let isReversed = false; let reverseTimer = 0;
        let playerHasBuff = false;
        let orb = { active: false, x: 0, y: 0 };
        let snakeStunTimer = 0; 

        const elS1=document.getElementById('snake-1'), elS2=document.getElementById('snake-2');
        const elWarn1=document.getElementById('warn-1'), elWarn2=document.getElementById('warn-2');
        const elArrow=document.getElementById('tunnel-indicator'), arrUp=elArrow.querySelector('.arrow-up'), arrDown=elArrow.querySelector('.arrow-down');
        const elDragon=document.getElementById('player-dragon');
        const elFXCont=document.getElementById('player-fx-container');
        const elPWarn=document.getElementById('p-warn-ring'), elPDispel=document.getElementById('p-dispel-ring');
        const fpsLbl = document.getElementById('fps-counter');

        const elMegaContainer = document.getElementById('mega-boss-container');
        const elMegaImg = document.getElementById('mega-boss-img');
        const elSonicWave = document.getElementById('sonic-wave');
        const elBossHud = document.getElementById('boss-hud'), elHpFill = document.getElementById('hp-fill');
        const elOrb = document.getElementById('energy-orb');

        const hbLayer=document.getElementById('hitbox-layer'), hbP=document.getElementById('hb-player'), hbOrb=document.getElementById('hb-orb');
        const hbS1H=document.getElementById('hb-s1-head'), hbS1B=document.getElementById('hb-s1-body');
        const hbS2H=document.getElementById('hb-s2-head'), hbS2B=document.getElementById('hb-s2-body');
        const lblGod=document.getElementById('lbl-god'), hitFlash=document.getElementById('immortal-hit');

        // SYSTEMS
        const elPoisonLayer = document.getElementById('poison-area-layer');
        
        let poisonTrapState = 'IDLE'; // IDLE -> WARN -> ACTIVE
        let isPoisonScreenActive = false; // Biến cờ chặn spawn

        const POOL_SIZE = 50; // Tạo sẵn 50 bãi độc (đủ dùng cho gridSize 170)
        const poisonPool = []; // Mảng chứa các DOM Element cố định

        // Hàm này sẽ chạy 1 lần duy nhất lúc khởi động game
        function initPoisonPool() {
            const layer = document.getElementById('poison-area-layer');
            // Xóa sạch layer cũ nếu có
            layer.innerHTML = '';
            poisonPool.length = 0;

            for (let i = 0; i < POOL_SIZE; i++) {
                const el = document.createElement('div');
                el.className = 'poison-puddle';
                layer.appendChild(el);
                poisonPool.push(el); // Đẩy vào kho chứa
            }
        }
        // Gọi ngay lập tức
        initPoisonPool();
        let poisonStateTimer = 0;
        let activePoisonBlobs = [];   // Chứa các DOM element của bãi độc
        let currentWarnEl = null;     // Element cảnh báo
        let targetSafeY = 0;          // Vị trí an toàn dự kiến
        let targetX = 0;              // Vị trí X của cột độc

        const CFG_AREA = {
            blobSize: 90,           // Kích thước bãi độc (px)
            safeGap: 180,           // Khoảng hở an toàn
            idleTime: 120,          // Thời gian nghỉ giữa các lần (frames)
            warnTime: 60,           // Thời gian cảnh báo (1 giây)
            activeTime: 180         // Thời gian tồn tại của độc (3 giây)
        };

        // Hàm Reset
        function clearPoisonArea() {
            // Trả cờ về false để game tiếp tục spawn rắn/đạn
            isPoisonScreenActive = false; 

            // Duyệt qua các bãi độc đang hiển thị
            activePoisonBlobs.forEach(el => {
                // [UPDATED] Bước 1: Thêm class hiệu ứng tan biến
                el.classList.add('puddle-vanish');
                
                // [UPDATED] Bước 2: Chờ 0.5s (bằng thời gian transition CSS)
                setTimeout(() => {
                    // Bước 3: Reset trạng thái gốc và trả về Pool
                    el.classList.remove('puddle-vanish'); // Xóa class tan biến
                    el.style.display = 'none';            // Ẩn đi
                    el.style.transform = 'scale(0)';      // Reset scale về 0
                    el.style.opacity = '0.95';            // Reset độ đậm
                }, 500);
            });
            
            // Làm rỗng mảng active ngay lập tức để logic game không tính va chạm nữa
            activePoisonBlobs = [];
            
            // Reset các biến trạng thái
            poisonTrapState = 'IDLE';
            poisonStateTimer = 0;
            if(currentWarnEl) { currentWarnEl.remove(); currentWarnEl = null; }
        }
        function updatePoisonLogic(delta) {
            // Chỉ chạy ở Phase 3 (Rắn cụt chân + đầu còn lại)
            let isPhase3 = (megaBoss.hp <= 34 && s1.destroyed);
            
            // Nếu chưa đến Phase 3 hoặc Boss chết/chưa spawn -> Reset và thoát
            if (!isPhase3 || !megaBoss.spawned || megaBoss.hp <= 0) {
                if(poisonTrapState !== 'IDLE') clearPoisonArea();
                return;
            }

            poisonStateTimer -= delta;

            // 1. Giai đoạn Nghỉ (IDLE) -> Chuyển sang Cảnh báo (WARN)
            // Chỉ chạy khi hết thời gian chờ (Cooldown)
            if (poisonTrapState === 'IDLE' && poisonStateTimer <= 0) {
                poisonTrapState = 'WARN';
                poisonStateTimer = CFG_AREA.warnTime;
                
                // BẬT CỜ CHẶN SPAWN
                isPoisonScreenActive = true; 

                // --- LOGIC VỊ TRÍ AN TOÀN ---
                const dRect = elDragon.getBoundingClientRect();
                targetX = dRect.left + dRect.width / 2; 
                targetSafeY = 150 + Math.random() * (window.innerHeight - 300);

                // TẠO VISUAL VÒNG TRÒN XANH
                currentWarnEl = document.createElement('div');
                currentWarnEl.className = 'safe-area-indicator';
                currentWarnEl.style.left = targetX + 'px';
                currentWarnEl.style.top = targetSafeY + 'px';
                elPoisonLayer.appendChild(currentWarnEl);

                // --- [SANCTUARY LOGIC] QUÉT VÀ XÓA MỐI ĐE DỌA ---
                const sanctuaryRadius = 180; 

                // A. XÓA ĐẠN
                for (let i = bossBullets.length - 1; i >= 0; i--) {
                    let b = bossBullets[i];
                    let dist = Math.sqrt(Math.pow(b.x - targetX, 2) + Math.pow(b.y - targetSafeY, 2));
                    if (dist < sanctuaryRadius) { b.el.remove(); bossBullets.splice(i, 1); }
                }

                // B. XÓA RẮN CON
                for (let i = babySnakes.length - 1; i >= 0; i--) {
                    let b = babySnakes[i];
                    let bCx = b.x + 60; let bCy = b.y + 15;
                    let dist = Math.sqrt(Math.pow(bCx - targetX, 2) + Math.pow(bCy - targetSafeY, 2));
                    if (dist < sanctuaryRadius) { b.el.remove(); babySnakes.splice(i, 1); }
                }
            }

            // 2. Giai đoạn Cảnh báo (WARN) -> Nổ độc (ACTIVE)
            else if (poisonTrapState === 'WARN' && poisonStateTimer <= 0) {
                poisonTrapState = 'ACTIVE';
                poisonStateTimer = CFG_AREA.activeTime;

                // Xóa cảnh báo vòng xanh
                if(currentWarnEl) { currentWarnEl.remove(); currentWarnEl = null; }

                // Rải độc né vùng tròn (X, Y) vừa tính
                spawnPoisonScreen(targetX, targetSafeY);
                triggerShake(false);
            }

            // 3. Giai đoạn Độc tồn tại (ACTIVE) -> Hết giờ -> Về Nghỉ (IDLE)
            else if (poisonTrapState === 'ACTIVE' && poisonStateTimer <= 0) {
                // Dọn dẹp bãi độc (Hiệu ứng tan biến)
                activePoisonBlobs.forEach(el => {
                    el.classList.add('puddle-vanish');
                    setTimeout(() => {
                        el.classList.remove('puddle-vanish');
                        el.style.display = 'none';
                        el.style.transform = 'scale(0)';
                        el.style.opacity = '0.95';
                    }, 500);
                });
                activePoisonBlobs = [];
                
                // Trả cờ về false để rắn/đạn spawn lại
                isPoisonScreenActive = false;
                
                // Reset trạng thái về IDLE
                poisonTrapState = 'IDLE';

                // --- [SỬA TẠI ĐÂY] RANDOM COOLDOWN ---
                // Thay vì CFG_AREA.idleTime, ta dùng random từ 200 đến 400 frames
                // Tương đương nghỉ khoảng 3.5s đến 6.5s trước đợt cảnh báo tiếp theo
                poisonStateTimer = 200 + Math.random() * 200; 
                
                console.log("Poison Cooldown:", Math.round(poisonStateTimer)); // Kiểm tra xem console có in ra số > 200 không
            }
        }
        // Hàm hỗ trợ rải độc
        function spawnPoisonScreen(safeX, safeY) {
            // 1. Dọn dẹp visual cũ (Soft Clear) - Không đụng vào biến trạng thái
            activePoisonBlobs.forEach(el => {
                el.style.display = 'none';
                el.style.transform = 'scale(0)';
            });
            activePoisonBlobs = [];

            const gridSize = 170; 
            const safeDistanceThreshold = 230; 
            
            let poolIndex = 0; 

            for (let gridX = -100; gridX < window.innerWidth + 100; gridX += gridSize) {
                for (let gridY = -100; gridY < window.innerHeight + 100; gridY += gridSize) {
                    
                    if (poolIndex >= POOL_SIZE) break;

                    let offX = (Math.random() - 0.5) * 80; 
                    let offY = (Math.random() - 0.5) * 80;

                    let finalSpawnX = gridX + offX; 
                    let finalSpawnY = gridY + offY; 

                    let blobCenterX = finalSpawnX + 90;
                    let blobCenterY = finalSpawnY + 90;

                    let dist = Math.sqrt( 
                        Math.pow(blobCenterX - safeX, 2) + 
                        Math.pow(blobCenterY - safeY, 2) 
                    );

                    if (dist < safeDistanceThreshold) continue; 

                    // Lấy từ Pool
                    const el = poisonPool[poolIndex];
                    activateFromPool(el, finalSpawnX, finalSpawnY);
                    
                    activePoisonBlobs.push(el);
                    poolIndex++;
                }
            }
        }
        function activateFromPool(el, x, y) {
            // 1. Đảm bảo sạch sẽ các class cũ
            el.classList.remove('puddle-vanish');
            
            // 2. [QUAN TRỌNG] Reset lại Opacity về mức hiển thị
            el.style.opacity = '0.95';

            // 3. Set vị trí
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            
            // 4. Hiển thị lên
            el.style.display = 'block';
            el.style.transform = 'scale(0)'; 

            // 5. Hiệu ứng xuất hiện
            const rot = Math.floor(Math.random() * 360);
            const scl = 0.8 + Math.random() * 0.7;

            requestAnimationFrame(() => {
                el.style.transform = `scale(${scl}) rotate(${rot}deg)`;
            });
        }
        function triggerExplosion(targetRect, count, colorPrimary, colorSecondary) {
            // Lấy tâm vụ nổ
            const cx = targetRect.left + targetRect.width / 2;
            const cy = targetRect.top + targetRect.height / 2;
            
            for (let i = 0; i < count; i++) {
                const p = document.createElement('div');
                p.className = 'b-part';
                
                // Set vị trí xuất phát (giữa tâm xác chết)
                p.style.left = cx + 'px';
                p.style.top = cy + 'px';
                
                // Random màu
                p.style.backgroundColor = Math.random() < 0.6 ? colorPrimary : colorSecondary;
                
                // Random box-shadow để hạt sáng lên
                p.style.boxShadow = `0 0 10px ${colorPrimary}`;

                // Tính hướng bay (Khoảng cách bay từ 100px đến 300px)
                const angle = Math.random() * Math.PI * 2;
                const dist = 50 + Math.random() * 250; 
                
                // Gán biến CSS để Animation tự chạy
                const tx = (Math.cos(angle) * dist) + 'px';
                const ty = (Math.sin(angle) * dist) + 'px';
                
                p.style.setProperty('--tx', tx);
                p.style.setProperty('--ty', ty);
                
                document.body.appendChild(p);
                
                // Xóa hạt khỏi DOM sau khi animation xong (0.8s)
                setTimeout(() => p.remove(), 800);
            }
        }
        function createOneBlob(x, y) {
            const el = document.createElement('div');
            el.className = 'poison-puddle';
            // Random lệch X, Y một chút cho tự nhiên
            let offX = (Math.random() - 0.5) * 40; 
            let offY = (Math.random() - 0.5) * 20;
            
            el.style.left = (x + offX) + 'px';
            el.style.top = (y + offY) + 'px';
            
            elPoisonLayer.appendChild(el);
            activePoisonBlobs.push(el);
        }  
        let babySnakes = []; 
        let babyPhaseActive = false; 
        let babyNextSpawn = 0;
        let babySafeY = window.innerHeight / 2;
        let babySafeTarget = window.innerHeight / 2;
        let babySafeChangeTimer = 0;
        const CFG_BABY = {
            speed: 35,          
            minDelay: 200,    
            maxDelay: 1500,     
            src: 'Image/child.png',
            safeGap: 250       
        }; 
        const elBabyContainer = document.getElementById('baby-container');

        function spawnBabyWave() {
            let safeY = tunnel.y + (Math.random() * 100 - 50); 
            if(safeY < 100) safeY = 150; if(safeY > window.innerHeight - 150) safeY = window.innerHeight - 200;
            let startY = 50, endY = window.innerHeight - 50, step = 70;
            for (let y = startY; y < endY; y += step) {
                if (y > safeY - CFG_BABY.gapHeight/2 && y < safeY + CFG_BABY.gapHeight/2) continue; 
                spawnSingleBaby(y);
            }
        }
        function spawnSingleBaby(yPos) {
            const warnLine = document.createElement('div');
            warnLine.className = 'baby-warn-line';
            warnLine.style.top = (yPos + 20) + 'px'; 
            elBabyContainer.appendChild(warnLine);

            setTimeout(() => {
                if(gameState !== 'RUNNING') { warnLine.remove(); return; }
                warnLine.remove();

                const img = document.createElement('img');
                img.src = CFG_BABY.src; 
                img.className = 'baby-snake';
                
                // Random scale từ 1.5 đến 3.0
                let scaleVal = 1.5 + Math.random() * 1.5;

                img.style.top = yPos + 'px';
                
                let flipY = Math.random() < 0.5 ? 1 : -1;
                
                // Scale hình ảnh
                img.style.transform = `scale(${scaleVal}, ${scaleVal * flipY})`; 
                img.style.width = '120px'; 
                
                elBabyContainer.appendChild(img);

                babySnakes.push({ 
                    el: img, 
                    x: window.innerWidth + 50, 
                    y: yPos, 
                    scale: scaleVal, // <--- LƯU LẠI SCALE ĐỂ TÍNH HITBOX
                    active: true 
                });
            }, 600); 
        }
        function updateBabySnakes(delta) {
            if (!babyPhaseActive) return;

            // A. LOGIC VÙNG AN TOÀN TRÔI DẠT
            babySafeChangeTimer -= (delta * 16);
            if(babySafeChangeTimer <= 0) {
                babySafeTarget = 150 + Math.random() * (window.innerHeight - 300);
                babySafeChangeTimer = 2000 + Math.random() * 1000;
            }
            babySafeY += (babySafeTarget - babySafeY) * 0.02 * delta;

            // B. LOGIC SPAWN RẮN
            babyNextSpawn -= (delta * 16); 
            if (babyNextSpawn <= 0) {
                // Chỉ spawn nếu KHÔNG CÓ bãi độc
                if (!isPoisonScreenActive) { 
                    let isAbove = Math.random() < 0.5;
                    let spawnY = 0;
                    let halfGap = CFG_BABY.safeGap / 2;
                    
                    if (isAbove) {
                        let limitBot = babySafeY - halfGap;
                        if (limitBot > 0) spawnY = Math.random() * limitBot; 
                        else spawnY = -100;
                    } else {
                        let limitTop = babySafeY + halfGap;
                        if (limitTop < window.innerHeight) {
                            spawnY = limitTop + Math.random() * (window.innerHeight - limitTop);
                        } else spawnY = window.innerHeight + 100;
                    }

                    if (spawnY > -50 && spawnY < window.innerHeight + 50) {
                        spawnSingleBaby(spawnY);
                    }
                    
                    // Reset timer khi đã spawn thành công
                    babyNextSpawn = CFG_BABY.minDelay + Math.random() * (CFG_BABY.maxDelay - CFG_BABY.minDelay);
                } else {
                    // Nếu đang có bãi độc thì chờ thêm một chút rồi thử lại (để không bị kẹt loop)
                    babyNextSpawn = 200;
                }
            } // <--- BẠN BỊ THIẾU DẤU NÀY Ở CODE CŨ

            // C. DI CHUYỂN & DỌN DẸP RẮN (Phần này phải nằm ngoài if bên trên)
            for (let i = babySnakes.length - 1; i >= 0; i--) {
                let b = babySnakes[i];
                b.x -= CFG_BABY.speed * delta;
                b.el.style.left = b.x + 'px';

                if (b.x < -300) { 
                    b.el.remove();
                    babySnakes.splice(i, 1);
                }
            }
        }
        function clearBabies() { 
            babySnakes.forEach(b => b.el.remove()); 
            babySnakes = []; 
            babyPhaseActive = false; 
            elBabyContainer.innerHTML = ''; 
            // Reset Safe Zone về giữa màn hình khi bắt đầu lại
            babySafeY = window.innerHeight / 2;
        }
        let bossBullets = []; 
        const CFG_BULLET = { 
            speed: 16, 
            safeRadius: 200 
        }; 
        const elBulletContainer = document.getElementById('bullet-container');
        function createBullet(x, y, angleV) {
            const div = document.createElement('div'); div.className = 'poison-bullet'; div.style.left = x + 'px'; div.style.top = y + 'px'; elBulletContainer.appendChild(div);
            bossBullets.push({ el: div, x: x, y: y, vx: -CFG_BULLET.speed, vy: angleV });
        }
        function spawnBulletPattern() {
            if (isPoisonScreenActive) return; 
            // Logic Phase 1 bỏ qua
            if(megaBoss.hp > 68 && !s2.destroyed) return;

            let bulletCount = 4; // Mặc định 4 viên
            
            // Phase 3: Bắn nhiều hơn (6 viên)
            if (s1.destroyed && s2.destroyed) {
                bulletCount = 6; 
            }

            let startX = window.innerWidth - 100; 
            
            // VÒNG LẶP SCATTER (Rải đạn ngẫu nhiên)
            for (let i = 0; i < bulletCount; i++) {
                let attemptY = 0;
                let isValid = false;
                
                // Thử tìm vị trí Y ngẫu nhiên không đè lên Orb
                // Thử 5 lần, nếu không tìm được thì bỏ qua viên này để tránh lag/bug
                for (let k = 0; k < 5; k++) {
                    attemptY = 50 + Math.random() * (window.innerHeight - 150);
                    
                    if (orb.active) { 
                        if (Math.abs(attemptY - orb.y) > CFG_BULLET.safeRadius) { 
                            isValid = true; break; 
                        } 
                    } else { 
                        isValid = true; break; 
                    }
                }
                
                if(isValid) {
                    // X ngẫu nhiên lệch nhau một chút để đạn không ra thành 1 hàng thẳng tắp
                    let scatterX = startX + Math.random() * 200; 
                    
                    // Y đã random ở trên (attemptY)
                    // VY (Vận tốc Y) nhẹ để đạn bay lượn sóng ít thôi
                    let vy = (Math.random() - 0.5) * 1.5; 
                    
                    createBullet(scatterX, attemptY, vy);
                }
            }
        }
        function updateBullets(delta) {
            for (let i = bossBullets.length - 1; i >= 0; i--) {
                let b = bossBullets[i]; b.x += b.vx * delta; b.y += b.vy * delta; b.el.style.left = b.x + 'px'; b.el.style.top = b.y + 'px';
                if (b.x < -100 || b.y < -100 || b.y > window.innerHeight + 100) { b.el.remove(); bossBullets.splice(i, 1); }
            }
        }
        function clearBullets() { bossBullets.forEach(b => b.el.remove()); bossBullets = []; }

        // MAIN LOGIC
        function updateGodLabel() { lblGod.innerText = GOD_MODE ? "ON" : "OFF"; lblGod.style.color = GOD_MODE ? "lime" : "red"; }
        function triggerShake(strong = false) {
            document.body.classList.remove('shake-screen'); document.body.classList.remove('shake-hard');
            void document.body.offsetWidth;
            if(strong) document.body.classList.add('shake-hard'); else document.body.classList.add('shake-screen');
        }
        function applyBossVisuals(mode) {
            const conf = (mode === 'SKILL' || mode === 'CHARGING') ? BOSS_CFG.skill : BOSS_CFG.normal;
            elMegaContainer.style.width = conf.width + 'px'; elMegaContainer.style.height = conf.width + 'px'; 
            if(megaBoss.spawned && megaBoss.hp > 0) { elMegaContainer.style.right = conf.right + 'px'; } else { elMegaContainer.style.right = - (conf.width + 400) + 'px'; }
            elMegaImg.style.transform = `translateY(${conf.topInfo}px)`;
        }
        function spawnOrb() {
            orb.active = true; orb.x = window.innerWidth; orb.y = tunnel.y + (Math.random() * 200 - 100);
            elOrb.style.display = 'block'; elOrb.style.left = orb.x + 'px'; elOrb.style.top = orb.y + 'px';
        }
        function updateOrbPos(delta) {
            if(!orb.active) return; orb.x -= (CFG.dashSpeed * 0.8) * delta; elOrb.style.left = orb.x + 'px'; elOrb.style.top = orb.y + 'px';
            if(orb.x < -100) { orb.active = false; elOrb.style.display = 'none'; }
        }

        function updateBossHP(damage) {
            megaBoss.hp -= damage;
            if(megaBoss.hp < 0) megaBoss.hp = 0;
            elHpFill.style.width = megaBoss.hp + '%';
            
            elMegaImg.classList.add('boss-hit-anim');
            setTimeout(()=>{ elMegaImg.classList.remove('boss-hit-anim'); }, 400);

            // LOGIC PHÁ HỦY & HIỆU ỨNG CHẾT
            // 1. Chân rắn (HP <= 68)
            if(megaBoss.hp <= 68 && !s2.destroyed) {
                 s2.destroyed = true; 
                 s2.active = false;
                 
                 // Hiệu ứng nổ cho chân rắn
                 let rect = elS2.getBoundingClientRect();
                 triggerExplosion(rect, 40, '#00ff00', '#8800ff'); // Xanh lá + Tím
                 
                 elS2.style.display = 'none'; // Ẩn hình sau khi lấy rect
                 
                 babyPhaseActive = true; 
                 babySpawnTimer = 60;    
                 triggerShake(true);
            }

            // 2. Đầu rắn trên (HP <= 35)
            if(megaBoss.hp <= 35 && !s1.destroyed) {
                 s1.destroyed = true; 
                 s1.active = false;
                 
                 // Hiệu ứng nổ cho thân trên
                 let rect = elS1.getBoundingClientRect();
                 triggerExplosion(rect, 40, '#ff00ff', '#550055'); // Tím hồng + Tím đậm
                 
                 elS1.style.display = 'none';
                 
                 poisonSpawnTimer = 100; // Trigger Phase 3 Poison
                 triggerShake(true);
            }

            // 3. Boss chết (Win Game)
            if(megaBoss.hp <= 0) {
                // Hiệu ứng nổ cực đại cho Đầu Boss
                let rect = elMegaContainer.getBoundingClientRect();
                triggerExplosion(rect, 100, '#ffcc00', '#ff0000'); // Vàng + Đỏ
                
                document.getElementById('go-text').innerText = "YOU WIN!";
                elMegaContainer.style.opacity = '0';
                gameOver();
            }
        }

        function triggerMegaAttack() {
            megaBoss.state = 'CHARGING';
            megaBoss.canUseSkill = false; // <--- KHÓA SKILL NGAY LẬP TỨC
            megaBoss.stateTimer = BOSS_CFG.waveDelay * 0.06;
            
            elMegaImg.src = 'Image/skill.gif'; 
            elMegaImg.classList.add('boss-charge-fx'); 
            applyBossVisuals('CHARGING');
        }
        function fireSonicWave() {
            megaBoss.state = 'FIRING';
            
            // --- DỌN DẸP VISUAL ---
            elMegaImg.classList.remove('boss-charge-fx'); // Tắt rung boss
            // ---------------------

            elSonicWave.style.display = 'block';
            elSonicWave.classList.remove('animate-wave');
            void elSonicWave.offsetWidth; 
            elSonicWave.classList.add('animate-wave');
            
            triggerShake(true); 
            spawnOrb();
            isReversed = true;
            spawnBulletPattern();
            let randomDur = BOSS_CFG.revMin + Math.random() * (BOSS_CFG.revMax - BOSS_CFG.revMin);
            reverseTimer = randomDur;
            document.body.classList.add('reversed');
        }
        function returnToIdle() {
            megaBoss.state = 'IDLE'; 
            let randomCD = BOSS_CFG.coolMin + Math.random() * (BOSS_CFG.coolMax - BOSS_CFG.coolMin);
            if (megaBoss.hp <= 34) randomCD *= 0.6; megaBoss.stateTimer = randomCD * 0.06; 
            elMegaImg.src = 'Image/head.gif'; applyBossVisuals('NORMAL');
        }
        function updateMegaBoss(delta, totalSeconds) {
            // ... (Giữ nguyên các dòng logic spawn/move của Boss ở đầu hàm) ...
            if (!megaBoss.spawned && totalSeconds > 10) { megaBoss.spawned = true; applyBossVisuals('NORMAL'); megaBoss.stateTimer = 180; elBossHud.style.display = 'flex'; elHpFill.style.width = '100%'; }
            if (megaBoss.spawned && megaBoss.hp <= 34) {
                 let moveY = Math.sin(totalSeconds * 2.5) * 250; elMegaContainer.style.transform = `translateY(calc(-50% + ${moveY}px))`;
            } else { elMegaContainer.style.transform = `translateY(-50%)`; }

            if (megaBoss.spawned && megaBoss.hp > 0) {
                if (megaBoss.stateTimer > 0) megaBoss.stateTimer -= delta;
                
                // [UPDATED] THÊM ĐIỀU KIỆN && megaBoss.canUseSkill
                if (megaBoss.state === 'IDLE' && megaBoss.stateTimer <= 0 && megaBoss.canUseSkill) {
                    triggerMegaAttack();
                }
                else if (megaBoss.state === 'CHARGING' && megaBoss.stateTimer <= 0) { 
                    fireSonicWave(); 
                    megaBoss.stateTimer = 100; 
                }
                else if (megaBoss.state === 'FIRING' && megaBoss.stateTimer <= 0) {
                    returnToIdle();
                }
            }

            // --- CẬP NHẬT LOGIC VISUAL PLAYER TẠI ĐÂY ---
            if (isReversed) {
                reverseTimer -= (delta * 16.6); // Đổi ra ms
                
                // 1. Logic Aura Buff Khổng lồ (Vẫn hiện nếu có buff)
                if (playerHasBuff) {
                    if (!elPWarn.classList.contains('buffed-aura')) elPWarn.classList.add('buffed-aura');
                } else {
                    elPWarn.classList.remove('buffed-aura');
                }

                // 2. Logic Gồng (anim-charge): Chỉ hiện khi SẮP HẾT GIỜ (<= 1500ms) + CÓ BUFF
                if (playerHasBuff && reverseTimer <= 1500) {
                    if (!elPWarn.classList.contains('anim-charge')) {
                        // Reset animation để nó chạy mượt từ đầu
                        elPWarn.classList.remove('anim-charge');
                        void elPWarn.offsetWidth; 
                        elPWarn.classList.add('anim-charge');
                    }
                } else {
                    // Chưa đến lúc hoặc mất buff thì tắt
                    elPWarn.classList.remove('anim-charge');
                }

                // Xử lý khi hết giờ đảo ngược
                if (reverseTimer <= 0) {
                    isReversed = false; 
                    document.body.classList.remove('reversed'); 
                    
                    // ... (Giữ nguyên logic xóa visual...) ...
                    
                    // --- [UPDATED] LOGIC HỒI CHIÊU (COOLDOWN) ---
                    // Xác định thời gian hồi chiêu dựa trên Phase
                    let cooldownTime = (megaBoss.hp <= 34) ? 1000 : 2000;
                    
                    console.log("Skill Ended. Cooldown:", cooldownTime);
                    
                    // Đặt Timeout để mở khóa skill
                    setTimeout(() => {
                        if(gameState === 'RUNNING' && megaBoss.hp > 0) {
                            megaBoss.canUseSkill = true;
                            console.log("Boss Ready!");
                        }
                    }, cooldownTime);
                    // ---------------------------------------------

                    elPDispel.classList.remove('buffed-burst');
                    if(playerHasBuff) { 
                        elPDispel.classList.add('buffed-burst'); 
                        updateBossHP(34); 
                        playerHasBuff = false; 
                        triggerShake(true); 
                    } else { 
                        triggerShake(false); 
                    }
                    elPDispel.classList.remove('anim-burst'); 
                    void elPDispel.offsetWidth; 
                    elPDispel.classList.add('anim-burst');
                }
            } else {
                elPWarn.classList.remove('buffed-aura', 'anim-charge');
            }
        }

        function updateTunnel(delta) {
            // [UPDATED] PHASE 3 CHECK: Nếu cả 2 phần thân rắn đã bị phá hủy
            // Thì không cần logic Tunnel nữa -> Ẩn mũi tên và thoát hàm ngay.
            if (s1.destroyed && s2.destroyed) {
                elArrow.style.display = 'none';
                return;
            }

            // --- Logic Tunnel cũ giữ nguyên bên dưới ---
            tunnel.timer -= delta;
            
            if (tunnel.state === 'IDLE' && tunnel.timer <= 0) {
                let nextY = 200 + Math.random() * (window.innerHeight - 400);
                
                // Đảm bảo vị trí mới cách vị trí cũ một khoảng đủ xa
                while (Math.abs(nextY - tunnel.y) < 100) {
                    nextY = 150 + Math.random() * (window.innerHeight - 300);
                }
                
                tunnel.targetY = nextY; 
                tunnel.state = 'WARN'; 
                tunnel.timer = CFG.t_warn; 
                elArrow.style.display = 'flex';
                
                // Hiển thị mũi tên đúng hướng
                if (tunnel.targetY < tunnel.y) { 
                    arrUp.style.display = 'block'; 
                    arrDown.style.display = 'none'; 
                } else { 
                    arrUp.style.display = 'none'; 
                    arrDown.style.display = 'block'; 
                }

            } else if (tunnel.state === 'WARN' && tunnel.timer <= 0) { 
                tunnel.state = 'MOVE'; 
                elArrow.style.display = 'none'; 

            } else if (tunnel.state === 'MOVE') {
                tunnel.y += (tunnel.targetY - tunnel.y) * CFG.tunnelSpeed * delta;
                
                if (Math.abs(tunnel.targetY - tunnel.y) < 2) { 
                    tunnel.state = 'IDLE'; 
                    tunnel.timer = CFG.t_stable; 
                }
            }
        }
        function updateSnake(obj, type, delta) {
            if((type===1 && s1.destroyed) || (type===2 && s2.destroyed)) return;
            obj.timers[0] -= delta;
            if(obj.timers[0]<=0) {
                let base = (type===1 ? CFG.s1_BaseY : CFG.s2_BaseY);
                let rawY = base + (Math.random()*CFG.randRange*2 - CFG.randRange);
                let limit = (type===1) ? tunnel.y - CFG.safePadding - 250 : tunnel.y + CFG.safePadding - 100;
                if(type===1 && rawY > limit) rawY = limit - Math.random()*30;
                if(type===2 && rawY < limit) rawY = limit + Math.random()*30;
                obj.destY = rawY; obj.timers[0] = 30 + Math.random()*50;
            }
            obj.y += (obj.destY - obj.y) * CFG.posLerp * delta;
            obj.timers[1] -= delta;
            if(obj.timers[1]<=0) { obj.destSpd = CFG.minSpeed + Math.random()*(CFG.maxSpeed - CFG.minSpeed); obj.timers[1] = 50 + Math.random()*80; }
            obj.currentSpd += (obj.destSpd - obj.currentSpd) * 0.05 * delta;
        }

        function updateDragon(delta) {
            let currentGravity = isReversed ? -CFG.gravity : CFG.gravity;
            if (isReversed) elDragon.style.transform = 'translateY(-50%) scaleY(-1)';
            else elDragon.style.transform = 'translateY(-50%) scaleY(1)';
            dragon.vy += currentGravity * delta;
            if (isReversed) { if(dragon.vy < -CFG.termVelocity) dragon.vy = -CFG.termVelocity; } else { if(dragon.vy > CFG.termVelocity) dragon.vy = CFG.termVelocity; }
            dragon.y += dragon.vy * delta;
            if(dragon.y > window.innerHeight - 80) { dragon.y = window.innerHeight - 80; dragon.vy = 0; }
            if(dragon.y < 0) { dragon.y = 0; dragon.vy = 0; }
            elDragon.style.top = dragon.y + 'px'; elFXCont.style.top = dragon.y + 'px';
        }

        function hit(x1, y1, w1, h1, x2, y2, w2, h2) { return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1; }
        const elDynDebug = document.getElementById('hb-dynamic-layer');

        function checkCollisions() {
            if(gameState !== 'RUNNING') return;
            
            let debugHTML = ""; 
            const addDb = (x, y, w, h) => {
                if(showHitbox) {
                    debugHTML += `<div class="debug-box debug-danger" style="left:${x}px; top:${y}px; width:${w}px; height:${h}px; display:flex;"></div>`;
                }
            };

            const dRect = elDragon.getBoundingClientRect();
            
            // Player Hitbox
            let pX = dRect.left - 2;
            let pY = dRect.top + 3;
            let pW = 77;
            let pH = 54;

            drawBox(hbP, pX, pY, pW, pH);

            // --- 1. CHECK ORB ---
            if(orb.active) {
                drawBox(hbOrb, orb.x, orb.y, 60, 60);
                if(hit(pX,pY,pW,pH, orb.x, orb.y, 60, 60)) { 
                    playerHasBuff = true; orb.active = false; elOrb.style.display = 'none'; 
                }
            } else hide(hbOrb);

            let dead = false;
            const check = (x1, y1, w1, h1) => { return hit(pX,pY,pW,pH, x1,y1,w1,h1); };

            // --- 2. SNAKE 1 (RẮN TRÊN) - [UPDATED REAL-TIME HITBOX] ---
            if(s1.active && !s1.destroyed) {
                // Lấy tọa độ Y thực tế của rắn + Offset hình ảnh (khoảng 140px từ top container)
                let boxY = s1.y + 140; 
                
                // Chiều cao hitbox giảm xuống 200px theo yêu cầu
                let boxH = 200; 
                
                // Mũi rắn (Điểm bắt đầu tính va chạm X)
                let noseX = s1.x + 50; 

                // Vẽ Hitbox: Kéo dài từ mũi rắn về phía sau (Bên phải màn hình)
                // Dùng 5000px để đảm bảo phủ hết thân rắn
                drawBox(hbS1B, noseX, boxY, 5000, boxH);
                hide(hbS1H); // Ẩn hitbox đầu, chỉ dùng hitbox thân

                // Logic Va Chạm:
                // 1. Nếu Player nằm trong vùng cao độ Y của rắn
                if (pY < boxY + boxH && pY + pH > boxY) {
                    // 2. Và Player nằm bên phải cái mũi rắn
                    if ((pX + pW) > noseX) dead = true; 
                }
            } else { hide(hbS1H); hide(hbS1B); }

            // --- 3. SNAKE 2 (RẮN DƯỚI) - [UPDATED REAL-TIME HITBOX] ---
            if(s2.active && !s2.destroyed) {
                // Lấy tọa độ Y thực tế. Do rắn dưới lật ngược và hướng lên,
                // Ta chỉnh offset nhỏ hơn (khoảng 40px) để hitbox khớp visual thân.
                let boxY = s2.y + 40; 
                
                // Chiều cao hitbox giảm xuống 200px
                let boxH = 200; 
                
                // Mũi rắn (Điểm va chạm X). Do rắn 2 chạy sang phải, thân nằm bên trái.
                let noseX = s2.x; 

                // Vẽ Hitbox: Kéo dài từ mũi rắn về phía sau (Bên trái màn hình)
                // left = noseX - 5000
                drawBox(hbS2B, noseX - 5000, boxY, 5000, boxH);
                hide(hbS2H);

                // Logic Va Chạm:
                // 1. Nếu Player nằm trong vùng cao độ Y của rắn
                if (pY < boxY + boxH && pY + pH > boxY) {
                    // 2. Và Player nằm bên trái cái mũi rắn
                    if (pX < noseX) dead = true; 
                }
            } else { hide(hbS2H); hide(hbS2B); }

            // --- 4. RẮN CON (BABY) ---
            if(babyPhaseActive) {
                for (let b of babySnakes) {
                    let baseW = 119; let baseH = 29;
                    let hW = baseW * b.scale;
                    let hH = baseH * b.scale;
                    let hX = b.x - 1; 
                    let hY = b.y + 2; 

                    addDb(hX, hY, hW, hH); 
                    if (check(hX, hY, hW, hH)) dead = true;
                }
            }
            
            // --- 5. ĐẠN & BÃI ĐỘC ---
            for (let b of bossBullets) {
                addDb(b.x, b.y+2, 120, 90);
                if(check(b.x, b.y+2, 120, 90)) dead = true;
            }
            for (let blob of activePoisonBlobs) {
                let rect = blob.getBoundingClientRect();
                let hX = rect.left + 10; let hY = rect.top + 10;
                addDb(hX, hY, 80, 80);
                if (check(hX, hY, 80, 80)) dead = true;
            }
            
            // RENDER DEBUG
            if(showHitbox) {
                elDynDebug.innerHTML = debugHTML;
                elDynDebug.style.display = 'block';
            } else {
                elDynDebug.innerHTML = '';
                elDynDebug.style.display = 'none';
            }

            if(dead) {
                if(GOD_MODE) { hitFlash.style.display = 'block'; setTimeout(()=>hitFlash.style.display='none', 50); } 
                else gameOver();
            }
        }   
        function drawBox(el, x, y, w, h) { if(!showHitbox) { el.style.display='none'; return; } el.style.display='flex'; el.style.left=x+'px'; el.style.top=y+'px'; el.style.width=w+'px'; el.style.height=h+'px'; }
        function hide(el) { el.style.display='none'; }
        function gameOver() { gameState='GAMEOVER'; document.getElementById('game-over').style.display='flex'; document.body.classList.remove('reversed'); }

        let frameCounter = 0;
        function loop(timestamp) {
            if (!lastTime) lastTime = timestamp; const dt = timestamp - lastTime; lastTime = timestamp; let delta = Math.min(dt / 16.67, 4.0);
            if(frameCounter % 15 === 0) fpsLbl.innerText = "FPS: " + Math.round(1000/dt);
            if(gameState==='GAMEOVER') { requestAnimationFrame(loop); return; }
            if(gameState==='RUNNING') {
                gameTime += dt / 1000; updateDragon(delta); updateMegaBoss(delta, gameTime); updateOrbPos(delta); updateBullets(delta); updateBabySnakes(delta); updatePoisonLogic(delta);
                phaseTimer += delta; frameCounter++; 
                if(phase===1) { elWarn1.style.display='flex'; elWarn1.style.top = (CFG.s1_BaseY+140)+'px'; if(phaseTimer > CFG.t_warn) { elWarn1.style.display='none'; phase=2; if(!s1.destroyed){s1.active=true; s1.currentSpd=CFG.dashSpeed; elS1.style.display='flex';} } }
                else if(phase===2) { if(s1.x < -300) { phase=3; phaseTimer=0; } }
                else if(phase===3) { if(phaseTimer > CFG.t_runWait) { phase=4; phaseTimer=0; } }
                else if(phase===4) { elWarn2.style.display='flex'; if(!s2.destroyed) { if(!s2.active) { s2.x=-100; s2.y=CFG.s2_BaseY; } } elWarn2.style.top = (CFG.s2_BaseY + 100) + 'px'; if(phaseTimer > CFG.t_warn) { elWarn2.style.display='none'; phase=5; if(!s2.destroyed){s2.active=true; s2.currentSpd=CFG.dashSpeed; elS2.style.display='flex';} } }
                else if(phase===5) { if(s2.x > window.innerWidth+200) phase=6; }

                if(snakeStunTimer > 0) { snakeStunTimer -= (dt); if(s1.active) s1.x += 15 * delta; if(s2.active) s2.x -= 15 * delta; } 
                else {
                    if(s1.active && !s1.destroyed) { if(phase===4||phase===5) s1.y+=(CFG.s1_SafeY_Intro - s1.y)*0.08*delta; else if(phase>=3) { if(phase===6){updateTunnel(delta); updateSnake(s1,1,delta);} else {tunnel.y=window.innerHeight/2; updateSnake(s1,1,delta);} } else s1.y+=(CFG.s1_BaseY - s1.y)*0.1*delta; s1.x -= s1.currentSpd * delta; }
                    if(s2.active && !s2.destroyed) { if(phase===6) updateSnake(s2, 2, delta); else s2.y=CFG.s2_BaseY; s2.x += s2.currentSpd * delta; }
                }
                
                if(!s1.destroyed && s1.active) elS1.style.transform=`translate(${s1.x}px, ${s1.y}px)`;
                if(!s2.destroyed && s2.active) elS2.style.transform=`translate(${s2.x}px, ${s2.y}px) scaleX(-1)`;
                checkCollisions();
            } else { dragon.y = window.innerHeight/2 + Math.sin(timestamp/300)*50; elDragon.style.top = dragon.y + 'px'; }
            requestAnimationFrame(loop);
        }

        function start() {
            if(gameState==='RUNNING') return;
            gameState='RUNNING'; phase=1; phaseTimer=0; gameTime=0;
            document.getElementById('start-msg').style.display='none'; 
            document.getElementById('game-over').style.display='none'; 
            document.getElementById('go-text').innerText = "CHẾT RỒI!";
            
            // RESET CÁC THỰC THỂ
            clearBabies(); 
            clearBullets(); 
            clearPoisonArea(); 
            
            s1.active=false; s1.destroyed=false; s1.x=window.innerWidth+600; elS1.style.display='none';
            s2.active=false; s2.destroyed=false; s2.x=0; elS2.style.display='none';
            tunnel.state='IDLE'; tunnel.y=window.innerHeight/2;
            
            megaBoss.spawned = false; megaBoss.state='IDLE'; megaBoss.hp=100; megaBoss.canUseSkill = true;
            elMegaImg.src='Image/head.gif'; elMegaContainer.style.opacity = '1';
            elBossHud.style.display = 'none'; elHpFill.style.width='100%';
            
            applyBossVisuals('NORMAL'); 
            isReversed = false; document.body.classList.remove('reversed');
            
            playerHasBuff = false; orb.active=false; elOrb.style.display='none'; snakeStunTimer = 0;
            elPWarn.classList.remove('anim-pulse', 'buffed-aura', 'anim-charge'); 
            
            // Ẩn cưỡng bức bằng CSS cho chắc chắn
            elPWarn.style.display = ''; 
            // --------------------

            elPDispel.classList.remove('anim-burst', 'buffed-burst');
            document.body.classList.remove('shake-screen');
            
            dragon.y = window.innerHeight/2; dragon.vy = 0;
            lastTime = performance.now();
        }

        function jump() { if(gameState !== 'RUNNING') return; dragon.vy = isReversed ? Math.abs(CFG.jumpForce) : CFG.jumpForce; }
        window.addEventListener('mousedown', jump);
        window.addEventListener('keydown', (e)=>{
            if(e.code==='Space') { if(gameState !== 'RUNNING') start(); else jump(); }
            if(e.code==='KeyH') { showHitbox=!showHitbox; hbLayer.style.display=showHitbox?'block':'none'; }
            if(e.code==='KeyG') { GOD_MODE = !GOD_MODE; updateGodLabel(); }
            if(e.code==='F5') location.reload();
            if(e.code==='KeyK') { 
                if(gameState === 'RUNNING') {
                    console.log("Cheat Activated: -35HP");
                    updateBossHP(35); // Trừ ngay 35 HP để chuyển giai đoạn
                }
            }
        });
        applyBossVisuals('NORMAL'); requestAnimationFrame(loop);
    </script>
</body>
</html>